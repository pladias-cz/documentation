[["index.html", "Pladias.cz documentation Chapter 1 Intro", " Pladias.cz documentation Pladias team 2026-02-02 Chapter 1 Intro Some concrete values (record counts, dictionary listings, etc.) are given in the document – their value corresponds to the state of the database at the time of documentation generation. This documentation is under develop, the priorities are: make things public to be done nearly everything "],["basic-facts-about-pladias.html", "Chapter 2 Basic facts about Pladias", " Chapter 2 Basic facts about Pladias History project started on 2014, first launch 2016 - instance for vascular plants of the Czech Republic Pladias 2019 new instance for nonvascular plants of the Czech Republic DaLiBor 2021 new instance for vegetation traits (having no occurrence data included) CEVS 2024 new instance for vascular plants of the Slovakia Pladias.sk Technology stack PostgreSQL + PostGIS + PostgREST Java with Play! Framework Geoserver Misc "],["trait-data.html", "2.1 Trait data", " 2.1 Trait data TBD "],["occurrence-data.html", "2.2 Occurrence data", " 2.2 Occurrence data The main amount of the records is comming from individual external data providers in the Czech Republic (Pladias as a secondary resource), only minority is imported to the Pladias as a primary storage. Table 2.1: Table 2.2: Records insitutional origin project name count Nálezová databáze ochrany přírody Agentura ochrany přírody a krajiny ČR 16632157 Česká národní fytocenologická databáze Masarykova univerzita 2053011 Floristická dokumentace Botanický ústav AV ČR, v. v. i. 1641901 Excerpce pro Atlas Botanický ústav AV ČR, v. v. i. 987711 Databáze lesnické typologie Ústav pro hospodářskou úpravu lesů 969759 Květena východních Čech Zdeněk Kaplan 227875 Floristické kurzy ČBS Česká botanická společnost 210242 Slavíkovy zaškrtávací formuláře Botanický ústav AV ČR, v. v. i. 136450 Nálezová databáze Jihočeské pobočky ČBS Jihočeská pobočka ČBS 129385 Excerpce floristické literatury Zdeněk Kaplan 75298 Květena Brna Zdeňka Lososová 68986 Nálezová databáze Moravskoslezské pobočky ČBS Moravskoslezská pobočka ČBS 65517 Flóra Ještědského hřbetu Petr Petřík 58391 Slavíkův floristický archiv Botanický ústav AV ČR, v. v. i. 56689 Cross-border plants CZ-AT Milan Štech 41838 Databáze rostlin kraje Vysočina Libor Ekrt 28603 Flóra Šumavy Milan Štech 21668 Nálezová databáze Moravskoslezská Nálezová databáze Moravskoslezská 6720 2.2.1 Validity status For description of the record validity, a four-level classification is used (so called “semafor”). Using priority, the final interpretation of the occurrence status for taxon-quadrant is derived. Table 2.3: Records count according to the status of validity name count priority color_code Přijatý záznam 1124852 3        Nejistý záznam 72251 2        Odmítnutý záznam 22833 1        Nerevidovaný záznam 22192265 0          2.2.2 Native status Table 2.4: Records count according to the originality status name count priority původní 13682 1 nepůvodní 6802 2 pěstovaný 3488 3 neurčeno 23388229 4   2.2.3 Copyright There are multiple record licence options available as shown in the table. In the near future, we will transfer P-P-P records to CC-BY-4.0. Table 2.5: Table 2.6: Licenses available id key description 6 CC-BY-SA Creative Commons Attribution-ShareAlike 4.0 5 CC-BY Creative Commons — Attribution 4.0 International 4 P-N-N neposkytovat záznamy třetím stranám a nezveřejnit na webu 3 P-N-P neposkytovat záznamy třetím stranám ale zveřejnit na webu 2 P-P-N poskytovat záznamy třetím stranám ale nezveřejnit na webu 1 P-P-P poskytovat záznamy třetím stranám a zveřejnit na webu   Table 2.5: Table 2.5: Usage of licenses key description count CC-BY Creative Commons — Attribution 4.0 International 48160 P-N-N neposkytovat záznamy třetím stranám a nezveřejnit na webu 28 P-P-P poskytovat záznamy třetím stranám a zveřejnit na webu 23364013 "],["exports-of-occurrence-data.html", "Chapter 3 Exports of occurrence data ", " Chapter 3 Exports of occurrence data "],["base-query-that-imitates-the-gui-search-form-results.html", "3.1 Base query that imitates the GUI search form results", " 3.1 Base query that imitates the GUI search form results SELECT records.id AS id, taxons_clear.name_lat AS jmeno_stand, records.original_name AS jmeno_orig, records.locality AS lokalita, records.nearest_town_text AS nejblizsi_obec, districts.name AS okres, CASE WHEN records.altitude_min IS NULL THEN records.altitude_max::text WHEN records.altitude_max IS NULL OR records.altitude_min = records.altitude_max THEN records.altitude_min::text ELSE records.altitude_min::text || &#39;-&#39; || records.altitude_max::text END AS nadmorska_vyska, records.latitude AS souradnice_lat, records.longitude AS souradnice_lon, records.gps_coords_source AS zdroj_souradnic, records.gps_coords_precision AS presnost_souradnic, CASE WHEN records.datum_precision = &#39;Y&#39; THEN to_char(records.datum, &#39;YYYY&#39;) WHEN records.datum_precision = &#39;M&#39; THEN to_char(records.datum, &#39;YYYY-MM&#39;) ELSE to_char(records.datum, &#39;YYYY-MM-DD&#39;) END AS datum, ( SELECT STRING_AGG(CASE WHEN name IS NULL OR name = &#39;&#39; THEN surname ELSE name || &#39; &#39; || surname END, &#39;; &#39; ORDER BY succession) FROM atlas.records_authors INNER JOIN atlas.authors ON authors.id = records_authors.authors_id WHERE records_id = records.id) AS nalezce, records.source as pramen, ( SELECT STRING_AGG(herbariums.name, &#39;; &#39;) FROM atlas.records_herbariums INNER JOIN atlas.herbariums ON herbariums.id = records_herbariums.herbariums_id WHERE records_id = records.id) AS herbar, phytochorions.phyto_id || &#39;. &#39; || phytochorions.name AS fytochorion, ( SELECT quadrants_full.code FROM geodata.quadrants_full WHERE st_within(records.coords_wgs, quadrants_full.geom_wgs) LIMIT 1) AS kvadrant, records.comment AS poznamka, record_validation_status.description AS validacni_status, record_originality_status.name_cz AS originalita, projects.name AS projekt, records.original_id AS externi_id, licenses.key AS licence FROM atlas.records LEFT JOIN public.taxons_clear on records.taxon_id = taxons_clear.id LEFT JOIN geodata.districts on records.district_id = districts.id LEFT JOIN geodata.phytochorions on records.phytochorion_id = phytochorions.rowid LEFT JOIN atlas.record_validation_status on records.validation_status = record_validation_status.id LEFT JOIN atlas.record_originality_status on records.originality_id = record_originality_status.id LEFT JOIN atlas.projects on records.project_id = projects.id LEFT JOIN public.licenses on records.license_id = licenses.id; "],["occurrence-status-including-aggregated-descendant-taxa-parent_id-is-the-taxon-to-be-reported-inlcuding-records-linked-to-itself-all-descendant-taxa.html", "3.2 occurrence status including aggregated descendant taxa (parent_id is the taxon to be reported, inlcuding records linked to itself + all descendant taxa)", " 3.2 occurrence status including aggregated descendant taxa (parent_id is the taxon to be reported, inlcuding records linked to itself + all descendant taxa) SELECT m.quadrant_name, (SELECT id FROM atlas.record_validation_status WHERE priority=max(status.priority) LIMIT 1) AS max_valid_status, tree.parent_id as pladias_id FROM public_web.m_plants_distribution m , atlas.record_validation_status status, public.m_descendant_taxons tree WHERE tree.descendant_id = m.taxon_id AND m.validation_status=status.id GROUP BY m.quadrant_name, tree.parent_id "],["gbif-interactions.html", "Chapter 4 GBIF interactions", " Chapter 4 GBIF interactions Since 2025, we do show records exported from GBIF in the Pladias internal app, as an point marker accompanied with a link to the specimen info page. To get the data, this query is used: link in case of only Zobodat data: dataset_key=857bce66-f762-11e1-a439-00145eb45e9a Date of GBIF export: GBIF.org (11 September 2025) GBIF Occurrence Download https://doi.org/10.15468/dl.cperjf Date of GBIF export: GBIF.org (26 November 2025) GBIF Occurrence Download https://doi.org/10.15468/dl.xamd2m Date of GBIF export: GBIF.org (18 December 2025) GBIF Occurrence Download https://doi.org/10.15468/dl.pf96mm "],["working-with-gbif-data-outside-of-pladias.html", "4.1 Working with GBIF data outside of Pladias", " 4.1 Working with GBIF data outside of Pladias GBIF data is available in the Pladias database, but not everyone needs this access. Especially for analyses, it is necessary to be able to process an individual export from GBIF and be able to pair it to Pladias taxa using the stored mapping. A recipe for the OpenRefine tool is available for this purpose: start OpenRefine; for Docker users simply (without data persistency) docker run -d -it -p 3333:3333 -e REFINE_MEMORY=8G abesesr/openrefine, for others please see https://openrefine.org/docs/manual/installing get data from GBIF in DarwinCore format (the “simple” format can not be used as the taxa mapping is done on original names, not on names interpreted by the Taxonomy Backbone), extract the zip file and take the file occurrence.txt visit http://127.0.0.1:3333/ and upload the file “create project”, that is check and confirm the data were loaded correctly (check “tabs (TSV)” is selected as a column separator + “Attempt to parse cell text into numbers” is also checked). switch to Undo/Redo tab and press Apply. When the bellow JSON code is pasted, the OpenRefine will produce a new columns “PladiasId” and “PladiasName” at the very beginning of the matrix. [ { &quot;op&quot;: &quot;core/column-addition-by-fetching-urls&quot;, &quot;engineConfig&quot;: { &quot;facets&quot;: [], &quot;mode&quot;: &quot;row-based&quot; }, &quot;baseColumnName&quot;: &quot;taxonKey&quot;, &quot;urlExpression&quot;: &quot;grel:\\&quot;https://api.pladias.cz/prest/rpc/gbif2pladias?gbif_id=\\&quot; + value&quot;, &quot;onError&quot;: &quot;set-to-blank&quot;, &quot;newColumnName&quot;: &quot;pladiasRAW&quot;, &quot;columnInsertIndex&quot;: 192, &quot;delay&quot;: 50, &quot;cacheResponses&quot;: true, &quot;httpHeadersJson&quot;: [ { &quot;name&quot;: &quot;authorization&quot;, &quot;value&quot;: &quot;&quot; }, { &quot;name&quot;: &quot;if-modified-since&quot;, &quot;value&quot;: &quot;&quot; }, { &quot;name&quot;: &quot;accept-language&quot;, &quot;value&quot;: &quot;&quot; }, { &quot;name&quot;: &quot;accept-encoding&quot;, &quot;value&quot;: &quot;&quot; }, { &quot;name&quot;: &quot;user-agent&quot;, &quot;value&quot;: &quot;OpenRefine 3.9.0 [TRUNK]&quot; }, { &quot;name&quot;: &quot;accept&quot;, &quot;value&quot;: &quot;*/*&quot; }, { &quot;name&quot;: &quot;accept-charset&quot;, &quot;value&quot;: &quot;&quot; } ], &quot;description&quot;: &quot;Create column pladiasRAW at index 192 by fetching URLs based on column taxonKey using expression grel:\\&quot;https://api.pladias.cz/prest/rpc/gbif2pladias?gbif_id=\\&quot; + value&quot; }, { &quot;op&quot;: &quot;core/column-move&quot;, &quot;columnName&quot;: &quot;pladiasRAW&quot;, &quot;index&quot;: 0, &quot;description&quot;: &quot;Move column pladiasRAW to position 0&quot; }, { &quot;op&quot;: &quot;core/column-addition&quot;, &quot;engineConfig&quot;: { &quot;facets&quot;: [], &quot;mode&quot;: &quot;row-based&quot; }, &quot;baseColumnName&quot;: &quot;pladiasRAW&quot;, &quot;expression&quot;: &quot;grel:value.parseJson()[0][\\&quot;pladias_id\\&quot;]&quot;, &quot;onError&quot;: &quot;set-to-blank&quot;, &quot;newColumnName&quot;: &quot;pladiasID&quot;, &quot;columnInsertIndex&quot;: 1, &quot;description&quot;: &quot;Create column pladiasID at index 1 based on column pladiasRAW using expression grel:value.parseJson()[0][\\&quot;pladias_id\\&quot;]&quot; }, { &quot;op&quot;: &quot;core/column-addition&quot;, &quot;engineConfig&quot;: { &quot;facets&quot;: [], &quot;mode&quot;: &quot;row-based&quot; }, &quot;baseColumnName&quot;: &quot;pladiasRAW&quot;, &quot;expression&quot;: &quot;grel:value.parseJson()[0][\\&quot;pladias_name\\&quot;]&quot;, &quot;onError&quot;: &quot;set-to-blank&quot;, &quot;newColumnName&quot;: &quot;pladiasName&quot;, &quot;columnInsertIndex&quot;: 1, &quot;description&quot;: &quot;Create column pladiasName at index 1 based on column pladiasRAW using expression grel:value.parseJson()[0][\\&quot;pladias_name\\&quot;]&quot; }, { &quot;op&quot;: &quot;core/column-removal&quot;, &quot;columnName&quot;: &quot;pladiasRAW&quot;, &quot;description&quot;: &quot;Remove column pladiasRAW&quot; } ] "],["how-is-gbif-import-done-by-admin.html", "4.2 How is gbif IMPORT done by @admin", " 4.2 How is gbif IMPORT done by @admin visit the link of the GBIF filter + download as a taxonList and as Simple using the taxonList export (it has Tab as separator), add new taxa into the convertor or update their info filter out names with less than 20 occurrences to reduce it a little bit.. filter out FAMILY rank replace all ’ with ’’ fill NULL in V column empty cells use the Excel formula, that is prepared to be in the first, newly pasted column =&quot;INSERT INTO gbif.taxa (taxon_key, scientific_name, accepted_taxon_key, accepted_scientific_name, taxon_rank, species, species_key) VALUES (&quot;&amp;B2&amp;&quot;,&#39;&quot;&amp;C2&amp;&quot;&#39;,&quot;&amp;D2&amp;&quot;,&#39;&quot;&amp;E2&amp;&quot;&#39;,&#39;&quot;&amp;G2&amp;&quot;&#39;,&#39;&quot;&amp;U2&amp;&quot;&#39;,&quot;&amp;V2&amp;&quot;) ON CONFLICT (taxon_key) DO UPDATE SET accepted_taxon_key = EXCLUDED.accepted_taxon_key, accepted_scientific_name = EXCLUDED.accepted_scientific_name, taxon_rank = EXCLUDED.taxon_rank, species = EXCLUDED.species, species_key = EXCLUDED.species_key ;&quot; cleanup &amp; truncate table: sql ALTER TABLE IF EXISTS gbif.records DROP CONSTRAINT IF EXISTS gbif_records_taxon_fkey; DROP INDEX IF EXISTS gbif.gbif_records_coords_idx; DROP INDEX IF EXISTS gbif.gbif_records_taxon_key_idx; DROP INDEX IF EXISTS gbif.gbif_records_year_idx; DROP INDEX IF EXISTS gbif.records_institution_code_idx; TRUNCATE TABLE gbif.records RESTART IDENTITY; upload occurrences from Simple on megastroj, import records.csv via admin.pladias.cz Console docker cp ./data/records.csv adminpladiascz-app-1:/srv/temp/data/records.csv &amp;&amp; nohup docker exec adminpladiascz-app-1 bin/console gbif:importRecords &gt; output.log 2&gt;&amp;1 &amp; due foreignKey remove records those are not mapped sql DELETE FROM gbif.records r WHERE NOT EXISTS (SELECT 1 FROM gbif.taxa t WHERE t.taxon_key = r.taxon_key); restore indexes ```sql ALTER TABLE IF EXISTS gbif.records ADD CONSTRAINT gbif_records_taxon_fkey FOREIGN KEY (taxon_key) REFERENCES gbif.taxa (taxon_key) MATCH SIMPLE ON UPDATE NO ACTION ON DELETE CASCADE; CREATE INDEX IF NOT EXISTS gbif_records_coords_idx ON gbif.records USING gist (coords) TABLESPACE pg_default; CREATE INDEX IF NOT EXISTS gbif_records_taxon_key_idx ON gbif.records USING btree (taxon_key ASC NULLS LAST) TABLESPACE pg_default; CREATE INDEX IF NOT EXISTS gbif_records_year_idx ON gbif.records USING btree (year ASC NULLS LAST) TABLESPACE pg_default; CREATE INDEX IF NOT EXISTS records_institution_code_idx ON gbif.records USING btree (institution_code COLLATE pg_catalog.”default” ASC NULLS LAST) TABLESPACE pg_default; ``` "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
